## Добро пожаловать в документацию библиотеки Millet

**Millet** - библиотека для создания диалоговых агентов.

### Вам может быть полезна библиотека, если 

- Вы пишите асинхронных текстовых ботов, со сложной ветвистой логикой (например виртуального ассистента для поиска дешевых авиабилетов).

Millet позволит описывать логику таких ботов очень просто, как если бы это был синхронный диалог с пользователем на input-print.

Только сравните скилл на input-print:

```python
def meeting_skill(message: str):
    name = input("What is your name?")
    print(f"Nice to meet you {name}!")
```

и этот же скилл в Millet:

```python
from millet import Skill

class MeetingSkill(Skill):
    def start(self, initial_message: str):
        name = self.ask(question="What is your name?")
        self.say(f"Nice to meet you {name}!")
```

если бы вы описывали даже такой простой диалог для асинхронного бота своими силами, то вам бы пришлось использовать state-машину
где-то хранить текущее состояние ожидания имени пользователя. С увеличением сложности диалога количество состояний будет только расти, как и головная боль в их поддержке.

- вы пишите бота, который работает с различными каналами связи (telegram, viber, vk, почта и тд.)

Концептуально логика формирования ответа пользователю не должна зависеть от инфраструктурных каналов передачи сообщений. 
Millet позволяет разделить эти слои и предоставляет готовые и понятные абстракции для описания ваших агентов.

Продал? Тогда погнали.

### Установка

```bash
pip install Millet
```

### Сходу простой пример

Возможно вы гений и поймете концепцию, просто посмотрев на пример.

Опишем агента, который умеет знакомиться:
```python
from typing import List
from millet import Agent, Skill

class MeetingSkill(Skill):
    def start(self, initial_message: str):
        name = self.ask(question="What is your name?")
        self.say(f"Nice to meet you {name}!")

def skill_classifier(message: str) -> List[Skill]:
    return [MeetingSkill()]

agent = Agent(skill_classifier=skill_classifier)
conversation = agent.conversation_with_user("user_id_in_system")
```

использование:
```shell
>>> conversation.query("Hello")
["What is your name?"]
>>> conversation.query("Bob")
["Nice to meet you Bob!"]
```

всем остальным рекомендуется продолжить чтение документации.

### Для начала познакомимся с основными понятиями:

**Агент** - это ваш виртуальный ассистент, в который пользователи могут слать запросы, а он будет формировать ответы.

**Скилл** - это умение вашего агента. Хотите научить его играть в города? Просто опишите скилл игры в города и подключите его к вашему агенту. Вот так вот просто.

**Пользователь** - какой-то человек, желающий воспользоваться скиллом вашего агента.

**Диалог** - это процесс использования пользователем скилла агента. Диалог подразумевает, что какой-то пользователь находится в каком-то состоянии использования скилла агента.

**Контекст диалога** - в ходе диалога ваш агент запрашивает у пользователя необходимые данные, для достижения цели скилла. Эти данные и есть контекст диалога.

**Контекст пользователя** - в ходе работы с пользователем ваш агент может узнать принципиально важные данные о пользователе, например имя. Вы можете спросить в каком-то скилле один раз имя и больше не спрашивать его никогда, потому что оно уже будет в контексте пользователя.

**Классификатор скиллов** - механизм определения каким скиллом хочет воспользоваться пользователь на основании его запроса. Библиотека дает возможность описать свой классификатор - это может быть сложная ML-модель либо старые добрые if-else.

**Релевантность** - иногда пользователь не хочет доводить до цели текущий скилл. Он может захотеть воспользоваться другим скиллом или просто закончить текущий. Релевантность определяет уместно ли текущее сообщение пользователя к текущему скиллу. Возможно это сообщение не очень уместно и стоит переключить скилл классификатором.


### Описание скиллов
Для создания своего скилла необходимо реализовать класс Skill.

```python
from millet import Skill

class MeetingSkill(Skill):
    def start(self, initial_message: str):
        name = self.ask(question="What is your name?")
        self.say(f"Nice to meet you {name}!")
```

Для того чтобы запросить какие-то уточнения от клиента в ходе выполнения скилла имеется ряд методов:

`say` - просто вывести ответ пользователю, упрвление пользователю не передается

---
`ask` - что-то спросить у пользователя, управление перейдет пользователю, когда от него будет получен ответ - скрипт продолжит свое выполнение с этого же места, метод вернет ответ пользователя

`specify` - то же самое что и ask, но произойдет вызов классификатора (необходимо применять этот метод когда вы не уверены, что ответ релевантен для текущего скилла и есть шанс что это запрос на начала другого скилла)

---
`finish` - звершить скилл, по сути можно просто вызвать return

`abort` - то же самое что и finish, но произойдет вызов классификатора (необходимо применять этот метод когда вы не уверены, что ответ релевантен для текущего скила и есть шанс что это запрос на начала другого скилл)

---
`restart` - перезапустить скилл с начала

`retry` - то же самое что и restart, но произойдет вызов классификатора (необходимо применять этот метод когда вы не уверены, что ответ релевантен для текущего скила и есть шанс что это запрос на начала другого скилл)


### direct_to
Иногда сложно уместить весь диалог в один скрипт или важно чтобы логика скрипта выполнялась ровно один раз (покупка чего-либо)
В таких случаях в методах с передачей управления пользователю предусмотрен параметр direct_to, в который нужно передать следующее состояние диалога
Состояние диалога - метод скила (по аналогии с методом start)


### Контекст агента

Сохранение контекста необходимо для хранения текущего состояния диалога с пользователем.
Из коробки поставляются следующие контексты:

- RAMAgentContext - хранение диалога в оперативной памяти, очищается при удалении экземпляра контекста из памяти
- RedisAgentContext - персистентное хранение диалога в Redis, не сбрасывается между передеплоями

Вы можете определить свой механизм хранения контекста реализовав абстрактный класс AgentContext. Например если вам нужно хранить контекст в postgres.

Т.к. скилы сохраняются полностью со всем состоянием их переменных, то вы можете использовать эту возможность 
для хранения необходимых переменных между запросами.

Примеры: 
`self.current_question_number`
https://github.com/odryfox/millet/blob/master/examples/quiz.py

`self.history_words`
https://github.com/odryfox/millet/blob/master/examples/word_chain_game.py

Контекст скилла сбрасывается при его завершении. 

`waiting_answer`
https://github.com/odryfox/millet/blob/master/examples/quiz.py
